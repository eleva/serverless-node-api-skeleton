import { PrismaClient } from '@prisma/client';
import { PrismaMariaDb } from '@prisma/adapter-mariadb';
import {
    GetSecretValueCommand,
    SecretsManagerClient
} from '@aws-sdk/client-secrets-manager';

/* =========================
   RESPONSE UTILITIES
========================= */

const successResponse = (statusCode, data = null, headers = {}) => {
    const response = {
        statusCode,
        headers: {
            'Content-Type': 'application/json',
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Credentials': true,
            'Access-Control-Expose-Headers': 'Content-Range, X-Total-Count',
            ...headers
        }
    };

    if (data !== null) {
        response.body = JSON.stringify(data);
    }

    return response;
};

const errorResponse = (statusCode = 500, message = 'Internal Server Error') => ({
    statusCode,
    headers: {
        'Content-Type': 'application/json',
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Credentials': true
    },
    body: JSON.stringify({ message })
});

const parseBody = (body) =>
    typeof body === 'string' ? JSON.parse(body) : body;

/* =========================
   SECRETS MANAGER
========================= */

const getSecretValue = async (secretName) => {
    const config =
        process.env.APP_ENV === 'local'
            ? {
                region: process.env.AWS_REGION,
                credentials: {
                    accessKeyId: process.env.AWS_ACCESS_KEY_ID,
                    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY
                }
            }
            : {};

    const client = new SecretsManagerClient(config);

    const response = await client.send(
        new GetSecretValueCommand({ SecretId: secretName })
    );

    if (response.SecretString) {
        return JSON.parse(response.SecretString);
    }

    throw new Error('Secret not found or empty');
};

/* =========================
   DB CREDENTIALS
========================= */

const getDbCredentials = async () => {
    let credentials = {
        host: process.env.DB_HOST,
        username: process.env.DB_USERNAME,
        password: process.env.DB_PASSWORD,
        dbname: process.env.DB_DATABASE
    };

    if (process.env.DB_SECRET) {
        const secret = await getSecretValue(process.env.DB_SECRET);
        credentials = {
            host: secret.host,
            username: secret.username,
            password: secret.password,
            dbname: secret.dbname
        };
    }

    return credentials;
};

/* =========================
   PRISMA SINGLETON (Lambda)
========================= */

let prisma;

const getPrismaClient = async () => {
    if (prisma) return prisma;

    const db = await getDbCredentials();

    const adapter = new PrismaMariaDb({
        host: db.host,
        port: 3306,
        user: db.username,
        password: db.password,
        database: db.dbname,
        connectionLimit: 5
    });

    prisma = new PrismaClient({ adapter });

    return prisma;
};

/* =========================
    INPUT VALIDATION
========================= */
const validateInput = (data, requiredFields) => {
    const errors = [];

    for (const field of requiredFields) {
        if (data[field.name] === undefined || data[field.name] === null) {
            errors.push(`Field '${field.name}' is required`);
        }
    }

    return {
        isValid: errors.length === 0,
        errors
    };
};

/* =========================
   JSON-Server compatible query parser
========================= */

const parseJsonServerQuery = (queryStringParameters) => {
    if (!queryStringParameters) {
        return { where: {}, orderBy: undefined, skip: 0, take: 10, embed: [] };
    }

    const params = queryStringParameters;
    let where = {};
    let orderBy = undefined;
    let skip = 0;
    let take = 10;
    let embed = [];

    // Handle pagination - json-server style
    if (params._page && params._per_page) {
        const page = parseInt(params._page, 10);
        const perPage = parseInt(params._per_page, 10);
        skip = (page - 1) * perPage;
        take = perPage;
    } else if (params._start !== undefined && params._end !== undefined) {
        skip = parseInt(params._start, 10);
        take = parseInt(params._end, 10) - skip;
    } else if (params._start !== undefined && params._limit !== undefined) {
        skip = parseInt(params._start, 10);
        take = parseInt(params._limit, 10);
    }

    // Handle sorting - json-server style
    if (params._sort) {
        const sortFields = params._sort.split(',');
        orderBy = [];

        sortFields.forEach(field => {
            const isDescending = field.startsWith('-');
            const fieldName = isDescending ? field.substring(1) : field;
            orderBy.push({ [fieldName]: isDescending ? 'desc' : 'asc' });
        });

        // If only one field, use object instead of array
        if (orderBy.length === 1) {
            orderBy = orderBy[0];
        }
    }

    // Handle embed relationships
    if (params._embed) {
        embed = params._embed.split(',').map(e => e.trim());
    }

    // Build where clause from query parameters
    Object.keys(params).forEach(key => {
        // Skip special json-server parameters
        if (key.startsWith('_')) return;

        const value = params[key];

        // Handle nested fields: a.b=value becomes where: { a: { b: value } }
        if (key.includes('.')) {
            const parts = key.split('.');
            let current = where;

            for (let i = 0; i < parts.length - 1; i++) {
                if (!current[parts[i]]) {
                    current[parts[i]] = {};
                }
                current = current[parts[i]];
            }

            current[parts[parts.length - 1]] = parseValue(value);
            return;
        }

        // Handle array index: arr[0]=value
        const arrayMatch = key.match(/^(.+)\[(\d+)\]$/);
        if (arrayMatch) {
            const [, fieldName, index] = arrayMatch;
            if (!where[fieldName]) {
                where[fieldName] = { has: parseValue(value) };
            }
            return;
        }

        // Handle comparison operators
        if (key.endsWith('_gt')) {
            const field = key.slice(0, -3);
            where[field] = { gt: parseValue(value) };
        } else if (key.endsWith('_gte')) {
            const field = key.slice(0, -4);
            where[field] = { gte: parseValue(value) };
        } else if (key.endsWith('_lt')) {
            const field = key.slice(0, -3);
            where[field] = { lt: parseValue(value) };
        } else if (key.endsWith('_lte')) {
            const field = key.slice(0, -4);
            where[field] = { lte: parseValue(value) };
        } else if (key.endsWith('_ne')) {
            const field = key.slice(0, -3);
            where[field] = { not: parseValue(value) };
        } else if (key.endsWith('_like')) {
            const field = key.slice(0, -5);
            where[field] = { contains: parseValue(value) };
        } else {
            // Regular equality
            where[key] = parseValue(value);
        }
    });

    return { where, orderBy, skip, take, embed };
};

const parseValue = (value) => {
    // Try to parse as number
    if (!isNaN(value) && value.trim() !== '') {
        return Number(value);
    }

    // Try to parse as boolean
    if (value === 'true') return true;
    if (value === 'false') return false;

    // Return as string
    return value;
};

const buildInclude = (embed, relations) => {
    if (embed.length === 0) return undefined;

    const include = {};
    embed.forEach(relation => {
        if (relations[relation]) {
            include[relation] = true;
        }
    });

    return Object.keys(include).length > 0 ? include : undefined;
};

/* =========================
   EXPORT
========================= */

export const utils = {
    parseBody,
    successResponse,
    errorResponse,
    getPrismaClient,
    validateInput,
    parseJsonServerQuery,
    buildInclude
};
